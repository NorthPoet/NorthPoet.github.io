<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第五章：面向对象编程 | 捞月亮の小北</title><meta name="author" content="捞月亮の小北"><meta name="copyright" content="捞月亮の小北"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 面向对象概述 软件开发方法：面向过程和面向对象   面向过程：关注点在实现功能的步骤上  PO：Procedure Oriented。代表语言：C语言 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 例如开汽车：启动、踩离合、挂挡、松离合、踩油门、车走了。 对于简单的流程是适合使用面向过程的方式进行的。复杂的流程不适合使用面向过">
<meta property="og:type" content="article">
<meta property="og:title" content="第五章：面向对象编程">
<meta property="og:url" content="https://northpoet.github.io/posts/aa351366.html">
<meta property="og:site_name" content="捞月亮の小北">
<meta property="og:description" content="1. 面向对象概述 软件开发方法：面向过程和面向对象   面向过程：关注点在实现功能的步骤上  PO：Procedure Oriented。代表语言：C语言 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 例如开汽车：启动、踩离合、挂挡、松离合、踩油门、车走了。 对于简单的流程是适合使用面向过程的方式进行的。复杂的流程不适合使用面向过">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/wallhaven-7poj6e-20240202213535-pv6wlwq.png">
<meta property="article:published_time" content="2024-07-18T01:35:44.000Z">
<meta property="article:modified_time" content="2024-07-27T05:45:11.234Z">
<meta property="article:author" content="捞月亮の小北">
<meta property="article:tag" content="JavaSE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/wallhaven-7poj6e-20240202213535-pv6wlwq.png"><link rel="shortcut icon" href="/img/north.ico"><link rel="canonical" href="https://northpoet.github.io/posts/aa351366.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 捞月亮の小北","link":"链接: ","source":"来源: 捞月亮の小北","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第五章：面向对象编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-27 13:45:11'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/chat/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/NorthPoet/images/images/wallhaven-7poj6e-20240202213535-pv6wlwq.png')"><nav id="nav"><span id="blog-info"><a href="/" title="捞月亮の小北"><span class="site-name">捞月亮の小北</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/chat/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第五章：面向对象编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-18T01:35:44.000Z" title="发表于 2024-07-18 09:35:44">2024-07-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-27T05:45:11.234Z" title="更新于 2024-07-27 13:45:11">2024-07-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%90%8E%E7%AB%AF/">Java后端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第五章：面向对象编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-面向对象概述">1. 面向对象概述</h2>
<p><strong>软件开发方法：面向过程和面向对象</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>面向过程：关注点在实现功能的步骤上</p>
<ul class="lvl-2">
<li class="lvl-4">PO：Procedure Oriented。代表语言：C语言</li>
<li class="lvl-4">面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</li>
<li class="lvl-4">例如开汽车：启动、踩离合、挂挡、松离合、踩油门、车走了。</li>
<li class="lvl-4">对于简单的流程是适合使用面向过程的方式进行的。复杂的流程不适合使用面向过程的开发方式。</li>
</ul>
</li>
<li class="lvl-2">
<p>面向对象：关注点在实现功能需要哪些对象的参与</p>
<ul class="lvl-2">
<li class="lvl-4">OO：Object Oriented 面向对象。包括OOA,OOD,OOP。OOA：Object Oriented Analysis 面向对象分析。OOD：Object Oriented Design 面向对象设计。OOP：Object Oriented Programming 面向对象编程。代表语言：Java、C#、Python等。</li>
<li class="lvl-4">面向对象就是分析出解决这个问题都需要哪些对象的参加，然后让对象与对象之间协作起来形成一个系统。</li>
<li class="lvl-4">例如开汽车：汽车对象、司机对象。司机对象有一个驾驶的行为。司机对象驾驶汽车对象。</li>
<li class="lvl-4">面向对象开发方式耦合度低，扩展能力强。例如采用面向过程生产一台电脑，不会分CPU、内存和硬盘，它会按照电脑的工作流程一次成型。采用面向对象生产一台电脑，CPU是一个对象，内存条是一个对象，硬盘是一个对象，如果觉得硬盘容量小，后期是很容易更换的，这就是扩展性。</li>
</ul>
</li>
</ul>
<p><strong>面向对象三大特征</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>封装（Encapsulation）</p>
</li>
<li class="lvl-2">
<p>继承（Inheritance）</p>
</li>
<li class="lvl-2">
<p>多态（Polymorphism）</p>
</li>
</ul>
<h2 id="2-类与对象">2. 类与对象</h2>
<p><strong>类：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>现实生活中事物与事物之间具有共同特征</p>
</li>
<li class="lvl-2">
<p>类实际上是一个模板 ，是一个抽象的概念</p>
</li>
<li class="lvl-2">
<p>状态在程序中对应属性。属性通常用变量来表示</p>
</li>
<li class="lvl-2">
<p>行为在程序中对应方法。用方法来描述行为动作。</p>
</li>
<li class="lvl-2">
<p><strong>类 = 属性 + 方法</strong></p>
</li>
</ul>
<p><strong>对象：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>实际存在的个体</p>
</li>
<li class="lvl-2">
<p>对象又称实例(instance)</p>
</li>
<li class="lvl-2">
<p>通过类可以实例化对象</p>
</li>
</ul>
<p><strong>类的定义：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>定义类的语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符列表] class 类名 &#123;</span><br><span class="line">	类体 = 属性 + 方法;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 属性 (实例变量) , 描述的是状态</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方法 ，描述的是行为动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.north.oop01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Stone</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/1/25$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>为什么要定义类？</p>
<ul class="lvl-2">
<li class="lvl-4">因为要通过类实例化对象。有了对象，让对象之间写作起来形成系统</li>
</ul>
</li>
<li class="lvl-2">
<p>一个类可以实例化多java对象(通过一个类可以造出多个java对象)</p>
</li>
<li class="lvl-2">
<p>实例变量是一个对象一份，比如创建3个学生对象，每个学生对象中应该有name变量</p>
</li>
<li class="lvl-2">
<p>实例变量属于成员变量 ，成员变量如果没有手动赋值，系统会赋默认值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">数据类型        默认值</span><br><span class="line">----------------------</span><br><span class="line"><span class="type">byte</span>            <span class="number">0</span></span><br><span class="line"><span class="type">short</span>           <span class="number">0</span></span><br><span class="line"><span class="type">int</span>             <span class="number">0</span></span><br><span class="line"><span class="type">long</span>            <span class="number">0L</span></span><br><span class="line"><span class="type">float</span>           <span class="number">0.0F</span></span><br><span class="line"><span class="type">double</span>          <span class="number">0.0</span></span><br><span class="line"><span class="type">boolean</span>         <span class="literal">false</span></span><br><span class="line"><span class="type">char</span>            \u0000</span><br><span class="line">引用数据类型      <span class="literal">null</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>对象的创建和使用：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>以下列程序为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.north.oop01;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Stone</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/1/25$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问对象的属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + s1.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + s1.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;性别：&quot;</span> + (s1.gender ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对属性进行操作</span></span><br><span class="line">        s2.name = <span class="string">&quot;陈平安&quot;</span>;</span><br><span class="line">        s2.age = <span class="number">19</span>;</span><br><span class="line">        s2.gender = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + s2.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + s2.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;性别：&quot;</span> + (s2.gender ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>对象的创建</p>
<ul class="lvl-2">
<li class="lvl-4">Student s1 ; 是什么？s1是变量名。Student 是一种数据类型名。属于引用数据类型</li>
<li class="lvl-4">s1 也是局部变量</li>
<li class="lvl-4">s1 变量中保存的是堆内存中Student 对象的内存地址</li>
<li class="lvl-4">其中 , s1有一个特殊的称呼：引用</li>
<li class="lvl-4">什么是引用？引用的本质是一个变量 ，这个变量中保存了java对象的内存地址</li>
<li class="lvl-4">引用和对象要区分开。对象在JVM堆中。引用是保存对象地址的变量</li>
</ul>
</li>
<li class="lvl-2">
<p>对象的使用</p>
<ul class="lvl-2">
<li class="lvl-4">读取属性值：<a target="_blank" rel="noopener" href="http://s2.name">s2.name</a></li>
<li class="lvl-4">修改属性值：<a target="_blank" rel="noopener" href="http://s2.name">s2.name</a> = “徐凤年”;</li>
</ul>
</li>
<li class="lvl-2">
<p>通过一个类可以实例化多个对象 , 如：Student类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>上述代码中的 name 和 age 为什么不能使用 <code>类名.</code>​去访问</p>
<ul class="lvl-2">
<li class="lvl-4">实例变量要想访问 ，必须先new 对象。通过引用来访问实例变量</li>
<li class="lvl-4">实例变量是不能通过类名直接访问的</li>
</ul>
</li>
</ul>
<h2 id="3-对象的内存分析-对象与引用">3. 对象的内存分析(对象与引用)</h2>
<p><img src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/image-20240203122036-gy75lv6.png" alt="image">​</p>
<ol>
<li class="lvl-3">
<p>new运算符会在JVM的堆内存中分配空间用来存储实例变量。new分配的空间就是Java对象。</p>
</li>
<li class="lvl-3">
<p>在JVM中对象创建后会有对应的内存地址，将内存地址赋值给一个变量，这个变量被称为引用。</p>
</li>
<li class="lvl-3">
<p>Java中的GC主要针对的是JVM的堆内存。</p>
</li>
<li class="lvl-3">
<p>空指针异常是如何发生的？</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PetTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建宠物对象</span></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pet</span>();</span><br><span class="line">        <span class="comment">// 给属性赋值</span></span><br><span class="line">        dog.name = <span class="string">&quot;小黑&quot;</span>;</span><br><span class="line">        dog.birth = <span class="string">&quot;2012-10-11&quot;</span>;</span><br><span class="line">        dog.sex = <span class="string">&#x27;雄&#x27;</span>;</span><br><span class="line">        <span class="comment">// 读取属性的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗的名字：&quot;</span> + dog.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗的生日：&quot;</span> + dog.birth);</span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗的性别：&quot;</span> + dog.sex);</span><br><span class="line">        dog = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 注意：引用一旦为null，表示引用不再指向对象了。但是通过引用访问name属性，编译可以通过。</span></span><br><span class="line">        <span class="comment">// 运行时会出现异常：空指针异常。NullPointerException。这是一个非常著名的异常。</span></span><br><span class="line">        <span class="comment">// 为什么会出现空指针异常？因为运行的时候会找真正的对象，如果对象不存在了，就会出现这个异常。</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;狗狗的名字：&quot; + dog.name);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 会出现空指针异常。</span></span><br><span class="line">        dog.eat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 会出现空指针异常。</span></span><br><span class="line">        <span class="comment">//dog.run();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>方法调用时参数是如何传递的？将变量中保存的值复制一份传递过去。</p>
</li>
<li class="lvl-3">
<p>初次认识this关键字：出现在实例方法中，代表当前对象。“this.”大部分情况下可以省略。this存储在实例方法栈帧的局部变量表的0号槽位上。</p>
</li>
</ol>
<h2 id="4-封装">4. 封装</h2>
<p><strong>什么是封装</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>封装是将一个对象所有<mark>状态(属性)</mark> , 以及 <mark>行为(方法)</mark> 统一封装到一个类中 ，从而隐藏了对象内部的具体实现细节，向外界提供了有限的访问接口 ，以实现对对象的保护和隔离</p>
</li>
</ul>
<p><strong>封装的好处</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>封装通过限制外部对对象内部的直接访问和修改，保证了数据的安全性 ，并提高了代码的可维护性和可复用性</p>
</li>
</ul>
<p><strong>在代码上如何实现封装</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>属性私有化， 对外提供getter和setter方法</p>
</li>
</ul>
<p><strong>实现封装的步骤：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一步：属性私有化(什么是私有化？使用private 进行修饰)</p>
<ul class="lvl-2">
<li class="lvl-4">属性私有化的作用是：禁止外部程序对该属性进行随意访问</li>
<li class="lvl-4">所有被private修饰的 ，都是私有的 ，私有的只能在本类中访问</li>
</ul>
</li>
<li class="lvl-2">
<p>第二步：对外提供setter和getter方法</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>访问一般包括两种：</p>
<ol>
<li class="lvl-7">
<p>读：读属性的值 ， 读的方法格式：getter , <code>getter方法是绝对安全的。因为这个方法是读取属性的值，不会涉及修改操作。</code>​</p>
</li>
<li class="lvl-7">
<p>改：修改属性的值 , 改的方法格式：setter , <code>setter方法当中就需要编写拦截过滤代码，来保证属性的安全。</code>​</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">100</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;对不起，您的年龄值不合法！&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// this. 大部分情况下可以省略。</span></span><br><span class="line">       <span class="comment">// this. 什么时候不能省略？用来区分局部变量和实例变量的时候。</span></span><br><span class="line">       <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="5-构造方法Constructor（构造器）">5. 构造方法Constructor（构造器）</h2>
<p><strong>构造方法有什么作用</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>作用1：对象的创建(通过调用构造方法可以完成对象的创建)</p>
</li>
<li class="lvl-2">
<p>作用2：对象的初始化(给对象的所有属性赋值就是对象的初始化)</p>
</li>
</ul>
<p>怎么定义构造方法呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符列表] 构造方法名(形参列表) &#123;</span><br><span class="line">	构造方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>注意：</p>
<ul class="lvl-2">
<li class="lvl-4">构造方法名必须和类名一致。</li>
<li class="lvl-4">构造方法不需要提供返回值类型。</li>
<li class="lvl-4">如果提供了返回值类型，那么这个方法就不是构造方法了 ，就变成普通方法了。</li>
</ul>
</li>
</ul>
<p><strong>构造方法怎么调用呢？</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用new 运算符来调用</p>
</li>
<li class="lvl-2">
<p>语法：new 构造方法名(实参)</p>
</li>
<li class="lvl-2">
<p>注意：构造方法最终执行结束之后，会自动将创建的对象内存地址返回。但构造方法体中不需要提供 <mark>&quot;return 值&quot;</mark> ；这样的语句</p>
</li>
</ul>
<p><strong>缺省构造器</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在java语言中，如果一个类没有显示的去定义构造方法 , 系统会默认提供一个无参的构造方法。(通常把这个构造方法叫做缺省构造器)</p>
</li>
</ul>
<p><strong>构造方法中给属性赋值了，为什么还需要单独定义set方法给属性赋值呢？</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在构造方法中赋值是对象第一次创建时属性赋的值。set方法可以在后期的时候调用，来完成属性值的修改</p>
</li>
</ul>
<p><strong>构造方法的执行原理</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>构造方法执行包括两个重要的阶段</p>
<ul class="lvl-2">
<li class="lvl-4">第一阶段：对象的创建</li>
<li class="lvl-4">第二阶段：对象的初始化</li>
</ul>
</li>
<li class="lvl-2">
<p>对象在什么时候创建的？</p>
<ul class="lvl-2">
<li class="lvl-4">new 的时候 ，会直接在堆内存中开辟空间。然后给所有属性赋默认值，完成对象的创建。(<mark>这个过程是在构造方法体执行之前就完成了</mark>)</li>
</ul>
</li>
<li class="lvl-2">
<p>对象初始化在什么时候完成的？</p>
<ul class="lvl-2">
<li class="lvl-4">构造方法体开始执行，标志着开始进行对象初始化。构造方法体执行完毕，表示对象初始化完成。</li>
</ul>
</li>
</ul>
<p><strong>构造代码块？</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>语法格式：<code>&#123; &#125;</code>​</p>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造代码块</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//System.out.println(&quot;构造代码块执行！&quot;);</span></span><br><span class="line">    <span class="comment">// 这里能够使用this，这说明，构造代码块执行之前对象已经创建好了，并且系统也完成了默认赋值。</span></span><br><span class="line">    <span class="comment">//System.out.println(this.name);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;iiiiiiiiiii = &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>构造代码块什么时候执行，执行几次？</p>
<ul class="lvl-2">
<li class="lvl-4">每一次在new的时候，都会先执行一次构造代码块</li>
<li class="lvl-4">构造代码块是在构造方法之前执行的</li>
</ul>
</li>
</ul>
<h2 id="6-this-关键字">6. this 关键字</h2>
<p><strong>this关键字的简单介绍</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>this 是一个关键字</p>
</li>
<li class="lvl-2">
<p>this 出现在实例方法中，代表当前对象。语法是：this</p>
</li>
<li class="lvl-2">
<p>通过this 可以访问实例变量 ，可以调用实例方法</p>
</li>
<li class="lvl-2">
<p>this 大部分情况下可以省略 ，用于区分局部变量和实例变量时不能省略</p>
</li>
<li class="lvl-2">
<p>this 不能出现在静态方法中</p>
</li>
<li class="lvl-2">
<p>this（实参） 语法：</p>
<ul class="lvl-2">
<li class="lvl-4"><code>只能出现在构造方法的第一行</code>​</li>
<li class="lvl-4">通过当前构造方法调用本类中其他的构造方法</li>
<li class="lvl-4">作用是：代码复用</li>
</ul>
</li>
<li class="lvl-2">
<p>this 本质上是一个引用</p>
</li>
<li class="lvl-2">
<p>this 中保存的也是对象的内存地址</p>
</li>
<li class="lvl-2">
<p>this 中保存的是当前对象的内存地址</p>
</li>
</ul>
<h2 id="7-static-关键字">7. static 关键字</h2>
<p><strong>static 关键字简单介绍</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>static 翻译为静态的</p>
</li>
<li class="lvl-2">
<p>static 修饰的变量 ，静态变量</p>
</li>
<li class="lvl-2">
<p>static 修饰的方法 ，静态方法</p>
</li>
<li class="lvl-2">
<p>所有static修饰的，访问的时候，直接采用&quot;类名.&quot; , 不需要new 对象</p>
</li>
</ul>
<p><strong>什么情况下把成员变量定义为静态成员变量？</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当一个属性是对象级别的 ，这个属性通常定义为实例变量。(实例变量时一个对象一份。100个对象就应该有100个空间)</p>
</li>
<li class="lvl-2">
<p>当一个属性是类级别的(所有对象都有这个属性) ，并且这个属性的值是一样的 ，建议将其定义为静态变量 ，在内存空间上只有一份 ，节省内存开始，这种类级别的属性不需要new对象，直接通过类名访问</p>
</li>
</ul>
<p><strong>静态变量存储在哪里？静态变量在什么时候初始化？(什么时候开辟空间)</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>JDK8 之后 ，静态变量存储在堆内存中</p>
</li>
<li class="lvl-2">
<p>类加载时初始化</p>
</li>
</ul>
<p><strong>静态变量可以采用&quot;引用.&quot; 来访问吗？</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>可以（但不建议：会给程序员造成困惑，程序员会认为country是一个实例变量。）</p>
</li>
<li class="lvl-2">
<p>建议还是使用“类名.”来访问。这是正规的。</p>
</li>
</ul>
<p><strong>什么时候会出现空指针异常</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>一个空引用访问实例相关的，都会出现空指针异常。</p>
</li>
</ul>
<p><strong>静态代码块</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>静态代码块什么时候执行？执行几次？</p>
<ul class="lvl-2">
<li class="lvl-4">静态代码块在类加载时执行 ，并且只执行一次</li>
</ul>
</li>
<li class="lvl-2">
<p>静态代码块可以编写多个 ，并且遵循自上而下的顺序依次执行</p>
</li>
<li class="lvl-2">
<p>静态代码块什么时候使用？</p>
<ul class="lvl-2">
<li class="lvl-4">本质上，静态代码块就是为程序员预留的一个特殊的时间点：类加载时刻</li>
<li class="lvl-4">如果你需要再类加载时刻执行一段程序的话，这段代码就可以写到静态代码块当中。</li>
<li class="lvl-4">例如，有这样一个需求：请在类加载时，记录日志。那么记录日志的代码就可以编写到静态代码块当中。</li>
</ul>
</li>
</ul>
<h2 id="8-JVM体系结构">8. JVM体系结构</h2>
<p><strong>JVM对应了一套规范（Java虚拟机规范），它可以有不同的实现</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>JVM规范是一种抽象的概念，它可以有多种不同的实现。例如：</p>
<ol>
<li class="lvl-5">HotSpot：HotSpot 由 Oracle 公司开发，是目前最常用的虚拟机实现，也是默认的 Java 虚拟机，默认包含在 Oracle JDK 和 OpenJDK 中</li>
<li class="lvl-5">JRockit：JRockit 也是由 Oracle 公司开发。它是一款针对生产环境优化的 JVM 实现，能够提供高性能和可伸缩性</li>
<li class="lvl-5">IBM JDK：IBM JDK 是 IBM 公司开发的 Java 环境，采用了与 HotSpot 不同的 J9 VM，能够提供更小的内存占用和更迅速的启动时间</li>
<li class="lvl-5">Azul Zing：Azul Zing 是针对生产环境优化的虚拟机实现，能够提供高性能和实时处理能力，适合于高负载的企业应用和实时分析等场景</li>
<li class="lvl-5">OpenJ9：OpenJ9 是由 IBM 开发的优化的 Java 虚拟机实现，支持高度轻量级、低时延的 GC、优化的 JIT 编译器和用于健康度测试的可观察性仪表板</li>
</ol>
</li>
<li class="lvl-2">
<p>右图是从oracle官网上截取的Java虚拟机规范中的一部分。（大家也可以找一下oracle官方文档）</p>
</li>
<li class="lvl-2">
<p>我们主要研究运行时数据区。运行时数据区包括6部分：</p>
<ol>
<li class="lvl-5">The pc Register（程序计数器）</li>
<li class="lvl-5">Java Virtual Machine Stacks（Java虚拟机栈）</li>
<li class="lvl-5">Heap（堆）</li>
<li class="lvl-5">Method Area（方法区）</li>
<li class="lvl-5">Run-Time Constant Pool（运行时常量池）</li>
<li class="lvl-5">Native Method Stacks（本地方法栈）</li>
</ol>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/image-20240204143027-9myyxjn.png" alt="image">​</p>
<p>‍</p>
<p><strong>JVM规范中的运行时数据区</strong></p>
<ol>
<li class="lvl-3">
<p>The pc Register（程序计数器）：是一块较小的内存空间，此计数器记录的是正在执行的虚拟机字节码指令的地址；</p>
</li>
<li class="lvl-3">
<p>Java Virtual Machine Stacks（Java虚拟机栈）：Java虚拟机栈用于存储栈帧。栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
</li>
<li class="lvl-3">
<p>Heap（堆）：是Java虚拟机所管理的最大的一块内存。堆内存用于存放Java对象实例以及数组。堆是垃圾收集器收集垃圾的主要区域。</p>
</li>
<li class="lvl-3">
<p>Method Area（方法区）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</li>
<li class="lvl-3">
<p>Run-Time Constant Pool（运行时常量池）：是方法区的一部分，用于存放编译期生成的各种字面量与符号引用。</p>
</li>
<li class="lvl-3">
<p>Native Method Stacks（本地方法栈）：在本地方法的执行过程中，会使用到本地方法栈。和 Java 虚拟机栈十分相似。</p>
</li>
<li class="lvl-3">
<p><mark>总结：这些运行时数据区虽然在功能上有所区别，但在整个 Java 虚拟机启动时都需要被创建，并且在虚拟机运行期间始终存在，直到虚拟机停止运行时被销毁。同时，不同的 JVM 实现对运行时数据区的分配和管理方式也可能不同，会对性能和功能产生影响。</mark></p>
</li>
</ol>
<p>JVM体系结构图（该图属于JVM规范，不是具体的实现）</p>
<p><img src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/image-20240204143209-8c8bxhc.png" alt="image">​</p>
<p>‍</p>
<p><strong>JVM规范的实现：HotSpot（Oracle JDK/Open JDK内部使用的JVM就是HotSpot）</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>以下是JDK6的HotSpot</p>
<ul class="lvl-2">
<li class="lvl-4">年轻代：刚new出来的对象放在这里。</li>
<li class="lvl-4">老年代：经过垃圾回收之后仍然存活的对象。</li>
<li class="lvl-4">符号引用：类全名，字段全名，方法全名等。</li>
<li class="lvl-4">这个时期的永久代和堆是相邻的，使用连续的物理内存，但是内存空间是隔离的。</li>
<li class="lvl-4">永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/image-20240204143318-6jltd96.png" alt="image">​</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>以下是JDK7的HotSpot，这是一个过渡的版本，该版本相对于JDK6来说，变化如下：</p>
<ol>
<li class="lvl-5">类的静态变量转移到堆中了</li>
<li class="lvl-5">字符串常量池转移到堆中了</li>
<li class="lvl-5">运行时常量池中的符号引用转移到本地内存了</li>
</ol>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/image-20240204143837-tb66scc.png" alt="image">​</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>以下是JDK8及更高版本的HotSpot，相对于JDK7来说发生了如下变化：</p>
<ol>
<li class="lvl-5">彻底删除永久代（为了避免OOM错误的发生）</li>
<li class="lvl-5">将方法区的实现转移到本地内存</li>
<li class="lvl-5">将符号引用重新放回运行时常量池</li>
</ol>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/image-20240204143934-bo7qciw.png" alt="image">​</p>
<h2 id="9-单例模式">9. 单例模式</h2>
<p><strong>设计模式概述</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>什么是设计模式？</p>
<ul class="lvl-2">
<li class="lvl-4">设计模式（Design Pattern）是一套被广泛接受的、经过试验验证的、可反复使用的基于面向对象的软件设计经验总结，它是软件开发人员在软件设计中，对常见问题的解决方案的总结和抽象。设计模式是针对软件开发中常见问题和模式的通用解决方案</li>
</ul>
</li>
<li class="lvl-2">
<p>设计模式有哪些？</p>
<ol>
<li class="lvl-5">GoF设计模式：《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为四人组（Gang of Four）。</li>
<li class="lvl-5">架构设计模式（Architectural Pattern）：主要用于软件系统的整体架构设计，包括多层架构、MVC架构、微服务架构、REST架构和大数据架构等。</li>
<li class="lvl-5">企业级设计模式（Enterprise Pattern）：主要用于企业级应用程序设计，包括基于服务的架构（SOA）、企业集成模式（EIP）、业务流程建模（BPM）和企业规则引擎（BRE）等。</li>
<li class="lvl-5">领域驱动设计模式（Domain Driven Design Pattern）：主要用于领域建模和开发，包括聚合、实体、值对象、领域事件和领域服务等。</li>
<li class="lvl-5">并发设计模式（Concurrency Pattern）：主要用于处理并发性问题，包括互斥、线程池、管道、多线程算法和Actor模型等。</li>
<li class="lvl-5">数据访问模式（Data Access Pattern）：主要用于处理数据访问层次结构，包括数据访问对象（DAO）、仓库模式和活动记录模式等。</li>
</ol>
</li>
<li class="lvl-2">
<p>GoF设计模式的分类？</p>
<ol>
<li class="lvl-5">创建型：主要解决对象的创建问题</li>
<li class="lvl-5">结构型：通过设计和构建对象之间的关系，以达到更好的重用性、扩展性和灵活性</li>
<li class="lvl-5">行为型：主要用于处理对象之间的算法和责任分配</li>
</ol>
</li>
</ul>
<p><strong>单例模式：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>饿汉式：类加载时对象就创建好了。不管这个对象用还是不用。提前先把对象创建好</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>实现步骤：</p>
<ul class="lvl-4">
<li class="lvl-6">
<p>第一步：构造方法私有化</p>
</li>
<li class="lvl-6">
<p>第二步：对外提供一个公开的静态的方法 ，用这个方法获取单个实例</p>
</li>
<li class="lvl-6">
<p>第三步：定义一个静态变量 ，在类加载的时候 ，初始化静态变量(只初始化一次)</p>
</li>
<li class="lvl-6">
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p>懒汉式：用到这个对象的时候再创建对象 ，别在类加载的时候创建对象</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>实现步骤：</p>
<ul class="lvl-4">
<li class="lvl-6">
<p>第一步：构造方法私有化</p>
</li>
<li class="lvl-6">
<p>第二步：对外提供一个静态方法 ，通过这个方法可以获取到 Singleton 对象</p>
</li>
<li class="lvl-6">
<p>第三步：提供一个静态变量 ，但是这个变量值为 null</p>
</li>
<li class="lvl-6">
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            s = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;对象创建了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="10-继承">10. 继承</h2>
<p><strong>继承的简单介绍：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>面向对象的三大特征之一：继承</p>
</li>
<li class="lvl-2">
<p>java只支持单继承 ，一个类只能直接继承一个类</p>
</li>
<li class="lvl-2">
<p>java不支持多继承 ，但支持多重继承(多层继承)</p>
</li>
<li class="lvl-2">
<p>子类继承父类后，除私有的不支持继承 ，构造方法不支持继承 , 其他的全部会继承</p>
</li>
<li class="lvl-2">
<p>一个类没有显示继承任何类时 ，默认继承<mark>java.lang.Object</mark>​</p>
</li>
</ul>
<p><strong>继承的作用</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>基本作用：代码复用</p>
</li>
<li class="lvl-2">
<p>重要作用：有了继承 ，才有了方法覆盖(方法重写)和多态机制</p>
</li>
</ul>
<p><strong>继承在java中如何实现</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>[修饰符列表] class 类名 extends 父类名() { }</p>
</li>
<li class="lvl-2">
<p>extends 翻译为扩展 ，表示子类继承父类后 ，子类是对父类的扩展</p>
</li>
</ul>
<p><strong>继承相关的术语：当B类继承A类时</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>A类称为：父类 ，超类 ，基类 ， superclass</p>
</li>
<li class="lvl-2">
<p>B类称为：子类 ，派生类 ，subclass</p>
</li>
</ul>
<h2 id="11-方法覆盖">11. 方法覆盖</h2>
<p><strong>回顾方法重载 overload</strong></p>
<ol>
<li class="lvl-3">
<p>什么时候考虑使用方法重载</p>
<ul class="lvl-2">
<li class="lvl-6">在一个类中，如果功能相似，可以考虑使用方法重载。</li>
<li class="lvl-6">这样做的目的是：代码美观，方便编程。</li>
</ul>
</li>
<li class="lvl-3">
<p>当满足什么条件的时候构成方法重载</p>
<ul class="lvl-2">
<li class="lvl-6">条件1：在同一个类中。</li>
<li class="lvl-6">条件2：相同的方法名。</li>
<li class="lvl-6">条件3：不同的参数列表：类型，个数，顺序</li>
</ul>
</li>
<li class="lvl-3">
<p>方法重载机制属于编译阶段的功能</p>
<ul class="lvl-2">
<li class="lvl-6">方法重载机制是给编译器看的。</li>
</ul>
</li>
</ol>
<p><strong>方法覆盖/override/方法重写/overwrite</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>什么时候考虑使用方法重写？</p>
<ul class="lvl-2">
<li class="lvl-4">当从父类中继承过来的方法，无法满足子类的业务需求时。</li>
</ul>
</li>
<li class="lvl-2">
<p>当满足什么条件的时候 ，构成方法重写？</p>
<ul class="lvl-2">
<li class="lvl-4">条件1：方法覆盖发生在具有继承关系的父子类之间。</li>
<li class="lvl-4">条件2：具有相同的方法名（必须严格一样）</li>
<li class="lvl-4">条件3：具有相同的形参列表（必须严格一样）</li>
<li class="lvl-4">条件4：具有相同的返回值类型（可以是子类型）</li>
</ul>
</li>
<li class="lvl-2">
<p>关于方法覆盖的细节</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>当子类将父类方法覆盖之后，将来子类对象调用方法的时候，一定会执行重写之后的方法。</p>
</li>
<li class="lvl-4">
<p>在java语言中，有一个注解，这个注解可以在编译阶段检查这个方法是否是重写了父类的方法。</p>
<ul class="lvl-4">
<li class="lvl-6">@Override注解是JDK5引入，用来标注方法，被标注的方法必须是重写父类的方法，如果不是重写的方法，编译器会报错。</li>
<li class="lvl-6">@Override注解只在编译阶段有用，和运行期无关。</li>
</ul>
</li>
<li class="lvl-4">
<p>如果返回值类型是引用数据类型，那么这个返回值类型可以是原类型的子类型</p>
</li>
<li class="lvl-4">
<p>访问权限不能变低，可以变高。</p>
</li>
<li class="lvl-4">
<p>抛出异常不能变多，可以变少。（后面学习异常的时候再说。）</p>
</li>
<li class="lvl-4">
<p>私有的方法，以及构造方法不能继承，因此他们不存在方法覆盖。</p>
</li>
<li class="lvl-4">
<p>方法覆盖针对的是实例方法。和静态方法无关。（讲完多态再说。）</p>
</li>
<li class="lvl-4">
<p>方法覆盖针对的是实例方法。和实例变量没有关系。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bird对继承过来的move()方法不满意。</span></span><br><span class="line"><span class="comment">     * Bird类有权利将move()方法进行重写/覆盖。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸟儿在飞翔！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getObj</span><span class="params">(<span class="type">long</span> a, String b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="12-多态">12. 多态</h2>
<p><strong>关于基本数据类型之间的类型转换</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一种：小容量转换成大容量，叫做自动类型转换。</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> i;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li class="lvl-2">
<p>第二种：大容量转换成小容量，不能自动转换，必须添加强制类型转换符才行。叫做强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>)x;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>除了基本数据类型之间的类型转换之外，对于引用数据类型来说，也可以进行类型转换。</p>
<p>只不过不叫做自动类型转换和强制类型转换。我们一般称为向上转型和向下转型。</p>
</blockquote>
<p><strong>关于Java语言中的向上转型和向下转型：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>向上转型(upcasting)：子 —&gt; 父 （可以等同看做自动类型转换。）</p>
</li>
<li class="lvl-2">
<p>向下转型(downcasting)：父 —&gt; 子 （可以等同看做强制类型转换。）</p>
</li>
<li class="lvl-2">
<p>注意：<code>不管是向上还是向下转型，两种类型之间必须要有继承关系，编译器才能编译通过。这是最基本的大前提。</code></p>
</li>
</ul>
<p><strong>向上转型和向下转型</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>多态的向上转型 ： 编译看左边 ，运行看右边</p>
</li>
<li class="lvl-2">
<p>其中在多态的向上转型中使用对象去调用方法时只能调用子类从父类那里继承的方法或者时重写的方法 ，而不能调用子类自己特有的方法。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这个程序中 ，所创建的对象可以去调用从父类那里继承下来的方法，而不能调用scratch()方法。除非使用向下转型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="comment">// 写一下Cat自己的行为</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫在爬树&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫在吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scratch</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>向下转型的使用前提是要先存在向上转型 ，利用强转使向上转换时穿件的对象进项创建新的对象来调用子类特有的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        tom.eat();</span><br><span class="line">        tom.move();</span><br><span class="line">        tom.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 多态 —— 向下转型</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">jerry</span> <span class="operator">=</span> (Cat) tom;</span><br><span class="line">        jerry.scratch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>向上转型(upcasting)：</strong></p>
<ol>
<li class="lvl-3">
<p>子 --&gt; 父</p>
</li>
<li class="lvl-4">
<p>也可以等同看做自动类型转换</p>
</li>
<li class="lvl-4">
<p>前提：两种类型之间要有继承关系</p>
</li>
<li class="lvl-4">
<p>父类型引用指向子类型对象。这个就是多态机制最核心的语法。</p>
</li>
</ol>
<p><strong>java程序包括两个重要的阶段：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一阶段：编译阶段</p>
<ul class="lvl-2">
<li class="lvl-4">在编译的时候，编译器只知道a2的类型是Animal类型。因此在编译的时候就会去Animal类中找move()方法。找到之后，绑定上去，此时发生静态绑定。能够绑定成功，表示编译通过。</li>
</ul>
</li>
<li class="lvl-2">
<p>第二阶段：运行阶段</p>
<ul class="lvl-2">
<li class="lvl-4">在运行的时候，堆内存中真实的java对象是Cat类型。所以move()的行为一定是Cat对象发生的。因此运行的时候就会自动调用Cat对象的move()方法。这种绑定称为运行期绑定/动态绑定。</li>
</ul>
</li>
</ul>
<blockquote>
<p>因为编译阶段是一种形态，运行的时候是另一种形态。因此得名：多态。</p>
</blockquote>
<p>‍</p>
<p><strong>instanceof 运算符的语法规则：</strong></p>
<ol>
<li class="lvl-3">
<p>instanceof运算符的结果一定是：true/false</p>
</li>
<li class="lvl-3">
<p>语法格式：<mark>(引用 instanceof 类型)</mark></p>
</li>
<li class="lvl-3">
<p>例如：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(a <span class="keyword">instanceof</span> Cat)</span><br><span class="line">	<span class="literal">true</span>表示什么？</span><br><span class="line">		a引用指向的对象是Cat类型。</span><br><span class="line">	<span class="literal">false</span>表示什么？</span><br><span class="line">		a引用指向的对象不是Cat类型。</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>注意：<mark>做向下转型之前，为了避免ClassCastException的发生，一般建议使用instanceof进行判</mark></p>
</li>
</ol>
<p><strong>软件开发七大原则</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>软件开发原则旨在引导软件行业的从业者在代码设计和开发过程中，遵循一些基本原则，以达到高质量、易维护、易扩展、安全性强等目标。软件开发原则与具体的编程语言无关的，属于软件设计方面的知识。</p>
</li>
<li class="lvl-2">
<p>软件开发七大原则？</p>
<ol>
<li class="lvl-5"><mark>开闭原则 (Open-Closed Principle，OCP)：一个软件实体应该对扩展开放，对修改关闭。即在不修改原有代码的基础上，通过添加新的代码来扩展功能。（最基本的原则，其它原则都是为这个原则服务的。）</mark></li>
<li class="lvl-5">单一职责原则：一个类只负责单一的职责，也就是一个类只有一个引起它变化的原因。</li>
<li class="lvl-5">里氏替换原则：子类对象可以替换其基类对象出现的任何地方，并且保证原有程序的正确性。</li>
<li class="lvl-5">接口隔离原则：客户端不应该依赖它不需要的接口。</li>
<li class="lvl-5">依赖倒置原则：高层模块不应该依赖底层模块，它们都应该依赖于抽象接口。换言之，面向接口编程。</li>
<li class="lvl-5">迪米特法则：一个对象应该对其它对象保持最少的了解。即一个类应该对自己需要耦合或调用的类知道得最少。</li>
<li class="lvl-5">合成复用原则：尽量使用对象组合和聚合，而不是继承来达到复用的目的。组合和聚合可以在获取外部对象的方法中被调用，是一种运行时关联，而继承则是一种编译时关联。</li>
</ol>
</li>
</ul>
<p><strong>多态在开发中的作用</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>降低程序的耦合度 ，提高程序的扩展能力</p>
</li>
<li class="lvl-2">
<p>尽量使用多态 ，面向抽象编程 ，不要面向具体编程</p>
</li>
<li class="lvl-2">
<p>代码演示：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>应用类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> North</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Master</span> <span class="variable">lisi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Master</span>();</span><br><span class="line">        lisi.feed(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-4">
<p>宠物类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> North</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-4">
<p>猫类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> North</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-4">
<p>狗类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> North</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗啃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-4">
<p>主人类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> North</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Master</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Pet pet)</span> &#123;</span><br><span class="line">        pet.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>‍</p>
<h2 id="13-super关键字">13. super关键字</h2>
<p><strong>super关键字介绍</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>this代表的是当前对象 ，super代表的是当前对象中的父类型特征</p>
</li>
<li class="lvl-2">
<p>super 不能使用在静态上下文中 ，同时this也是</p>
</li>
<li class="lvl-2">
<p>super大部分情况下是可以省略的，==其中不能省略的情况为：==​</p>
<ul class="lvl-2">
<li class="lvl-4">当父类和子类中定义了相同的属性（实例变量）或者相同方法（实例方法）时，如果需要在子类中访问父类的属性或方法时，super.不能省略。</li>
</ul>
</li>
<li class="lvl-2">
<p>this可以单独输出，super不能单独输出。</p>
</li>
<li class="lvl-2">
<p>super(实参); 通过子类的构造方法调用父类的构造方法，==目的是为了完成父类型特征的初始化。==​</p>
</li>
<li class="lvl-2">
<p>当一个构造方法第一行没有显示的调用“super(实参);”，也没有显示的调用“this(实参)”，系统会自动调用super()。因此一个类中的无参数构造方法建议显示的定义出来。</p>
</li>
<li class="lvl-2">
<p><code>super(实参); 这个语法只能出现在构造方法第一行。</code>​</p>
</li>
<li class="lvl-2">
<p>在Java语言中只要new对象，Object的无参数构造方法一定会执行。</p>
</li>
</ul>
<p>部分代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 重写的要求：要求在父类方法的执行基础之上额外再添加一些代码。</span></span><br><span class="line">System.out.println(<span class="string">&quot;do some开始执行了&quot;</span>);</span><br><span class="line"><span class="comment">// super. 什么时候不能省略？父中有，子中有相同的，但是想在子类中访问父的，必须添加 super.</span></span><br><span class="line"><span class="built_in">super</span>.doSome();</span><br><span class="line">System.out.println(<span class="string">&quot;do some方法执行结束了&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// this本身是一个引用。所以可以直接输出。</span></span><br><span class="line">System.out.println(<span class="built_in">this</span>);</span><br><span class="line"><span class="comment">// super本身不是一个引用。super只是代表了当前对象的父类型特征那部分。</span></span><br><span class="line"><span class="comment">// super 不能够单独的输出。</span></span><br><span class="line"><span class="comment">//System.out.println(super); // 编译报错。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-final关键字">14. final关键字</h2>
<p><strong>final关键字介绍</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>final表示最终的，不可变的。</p>
</li>
<li class="lvl-2">
<p>final修饰的类无法被继承。</p>
</li>
<li class="lvl-2">
<p>final修饰的变量一旦赋值，不能重新赋值。</p>
</li>
<li class="lvl-2">
<p>final修饰的方法无法覆盖。</p>
</li>
<li class="lvl-2">
<p>final修饰的实例变量。必须在构造方法执行完之前手动赋上值。（不允许采用系统默认值） 一般不存在这种情况。</p>
</li>
<li class="lvl-2">
<p>final修饰的实例变量一般和static联合使用，这就是著名的：常量。</p>
</li>
<li class="lvl-2">
<p>final修饰的引用：一旦指向了某个对象，则不能再指向其它对象。但指向的对象内部的数据是可以修改的。</p>
</li>
</ul>
<p><strong>常量的命名：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MATH_PAI</span> <span class="operator">=</span> <span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>常量的定义：<mark>public static final 数据类型 常量名 = 常量值;</mark></p>
</li>
<li class="lvl-2">
<p>常量名的命名规范：全部单词大写，每个单词采用“_”衔接。</p>
</li>
</ul>
<h2 id="15-抽象类">15. 抽象类</h2>
<p><strong>什么时候考虑将类定义为抽象类？</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>如果类中有些方法无法实现或者没有意义，可以将方法定义为抽象方法。类定义为抽象类。</code>​这样在抽象类中只提供公共代码，具体的实现强行交给子类去做。</p>
</li>
<li class="lvl-2">
<p>比如一个Person类有一个问候的方法greet()，但是不同国家的人问候的方式不同，因此greet()方法具体实现应该交给子类。再比如主人喂养宠物的例子中的宠物Pet，Pet中的eat()方法的方法体就是没有意义的。</p>
</li>
</ul>
<p><strong>抽象类如何定义？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> class 类名&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>抽象类有构造方法，但无法实例化。抽象类的构造方法是给子类使用的。</p>
</blockquote>
<p><strong>抽象方法如何定义？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> 方法返回值类型 方法名(形参);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>抽象类中不一定有抽象方法，但如果有抽象方法那么类要求必须是抽象类。</p>
</blockquote>
<p>一个非抽象的类继承抽象类，要求必须将抽象方法进行实现/重写。</p>
<p>abstract关键字不能和private，final，static关键字共存。</p>
<h2 id="16-接口">16. 接口</h2>
<p><strong>接口的简单介绍</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>接口（interface）在Java中表示一种规范或契约，它定义了一组抽象方法和常量，用来描述一些实现这个接口的类应该具有哪些行为和属性。</p>
</li>
<li class="lvl-2">
<p>接口和类一样，也是一种引用数据类型</p>
</li>
<li class="lvl-2">
<p>接口怎么定义？[修饰符列表] interface 接口名{}</p>
</li>
<li class="lvl-2">
<p>抽象类是半抽象的，接口是完全抽象的。接口没有构造方法，也无法实例化</p>
</li>
<li class="lvl-2">
<p>(JDK8之前的语法规则) 接口中只能定义：常量+抽象方法。接口中的常量的static final可以省略。接口中的抽象方法的abstract可以省略。接口中所有的方法和变量都是public修饰的</p>
</li>
<li class="lvl-2">
<p>接口和接口之间可以多继承</p>
</li>
<li class="lvl-2">
<p>类和接口的关系我们叫做实现（这里的实现也可以等同看做继承）。使用implements关键字进行接口的实现。</p>
</li>
<li class="lvl-2">
<p>一个非抽象的类实现接口必须将接口中所有的抽象方法全部实现（强制要求的，必须的，要不然编译器报错。）</p>
</li>
<li class="lvl-2">
<p>一个类可以实现多个接口。语法是：class 类 implements 接口A,接口B{}</p>
</li>
<li class="lvl-2">
<p>Java8之后，接口中允许出现默认方法和静态方法(JDK8新特性)</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>默认方法：</p>
<ul class="lvl-4">
<li class="lvl-6">引入默认方式是为了解决接口演变问题：接口可以定义抽象方法，但是不能实现这些方法。</li>
<li class="lvl-6">所有实现接口的类都必须实现这些抽象方法。这会导致接口升级的问题：当我们向接口添加或删除一个抽象方法时，</li>
<li class="lvl-6">这会破坏该接口的所有实现，并且所有该接口的用户都必须修改其代码才能适应更改。这就是所谓的&quot;接口演变&quot;问题</li>
</ul>
</li>
<li class="lvl-4">
<p>静态方法：</p>
<ul class="lvl-4">
<li class="lvl-6">注意：java中规定，在JDK8之后，接口中可以一定静态方法，但是这个静态方法，只能通过“该接口名”去调用的。别的都无法调用。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p>在JDK8之后引入接口可以定义静态方法，实际上想表达一个意思：接口也可以作为工具来使用了。</p>
</li>
<li class="lvl-2">
<p>JDK9之后允许接口中定义私有的实例方法（为默认方法服务的）和私有的静态方法（为静态方法服务的）</p>
</li>
<li class="lvl-2">
<p>所有的接口隐式的继承Object。因此接口也可以调用Object类的相关方法</p>
</li>
</ul>
<p><strong>接口的作用</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>面向接口调用的称为：接口调用者</p>
</li>
<li class="lvl-2">
<p>面向接口实现的称为：接口实现者</p>
</li>
<li class="lvl-2">
<p>调用者和实现者通过接口达到了解耦合。也就是说调用者不需要关心具体的实现者，实现者也不需要关心具体的调用者，双方都遵循规范，面向接口进行开发。</p>
</li>
<li class="lvl-2">
<p>==面向抽象编程，面向接口编程，可以降低程序的耦合度，提高程序的扩展力。==​</p>
</li>
<li class="lvl-2">
<p>例如定义一个Usb接口，提供read()和write()方法，通过read()方法读，通过write()方法写：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>定义一个电脑类Computer，它是调用者，面向Usb接口来调用。</p>
</li>
<li class="lvl-4">
<p>Usb接口的实现可以有很多，例如：打印机（Printer），硬盘（HardDrive）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conn</span><span class="params">(Usb usb)</span>&#123;</span><br><span class="line">  </span><br><span class="line">	usb.read();</span><br><span class="line">	usb.write();</span><br><span class="line">  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li class="lvl-2">
<p>再想想，我们平时去饭店吃饭，这个场景中有没有接口呢？食谱菜单就是接口。顾客是调用者。厨师是实现者。</p>
</li>
</ul>
<p><strong>接口与抽象类如何选择</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>抽象类和接口虽然在代码角度都能达到同样的效果，但适用场景不同：</p>
<ul class="lvl-2">
<li class="lvl-4">抽象类主要适用于公共代码的提取。当多个类中有共同的属性和方法时，为了达到代码的复用，建议为这几个类提取出来一个父类，在该父类中编写公共的代码。如果有一些方法无法在该类中实现，可以延迟到子类中实现。这样的类就应该使用抽象类。</li>
<li class="lvl-4">接口主要用于功能的扩展。例如有很多类，一些类需要这个方法，另外一些类不需要这个方法时，可以将该方法定义到接口中。需要这个方法的类就去实现这个接口，不需要这个方法的就可以不实现这个接口。接口主要规定的是行为。</li>
</ul>
</li>
</ul>
<h2 id="17-UML">17. UML</h2>
<p><img src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/image-20240214101255-rl5xbtp.png" alt="image">​</p>
<p><img src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/image-20240214101313-8lva3y9.png" alt="image">​</p>
<h2 id="18-访问控制权限">18. 访问控制权限</h2>
<p><img src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/image-20240214101348-e839l6o.png" alt="image">​</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>private：私有的，只能在本类中访问。</p>
</li>
<li class="lvl-2">
<p>缺省：默认的，同一个包下可以访问。</p>
</li>
<li class="lvl-2">
<p>protected：受保护的，子类中可以访问。（受保护的通常就是给子孙用的。）</p>
</li>
<li class="lvl-2">
<p>public：公共的，在任何位置都可以访问。</p>
<p>‍</p>
</li>
<li class="lvl-2">
<p>类中的属性和方法访问权限共有四种：private、缺省、protected和public。</p>
</li>
<li class="lvl-2">
<p>类的访问权限只有两种：public和 缺省。</p>
</li>
<li class="lvl-2">
<p>访问权限控制符不能修饰局部变量。</p>
</li>
</ul>
<h2 id="19-Object-类">19. Object 类</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>java.lang.Object是所有类的超类。java中所有类都实现了这个类中的方法。</p>
</li>
<li class="lvl-2">
<p>现阶段Object类中需要掌握的方法：</p>
<ul class="lvl-2">
<li class="lvl-4">toString：将java对象转换成字符串。</li>
<li class="lvl-4">equals：判断两个对象是否相等。</li>
</ul>
</li>
<li class="lvl-2">
<p>现阶段Object类中需要了解的方法：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>hashCode：返回一个对象的哈希值，通常作为在哈希表中查找该对象的键值。Object类的默认实现是根据对象的内存地址生成一个哈希码（即将对象的内存地址转换为整数作为哈希值）。hashCode()方法是为了HashMap、Hashtable、HashSet等集合类进行优化而设置的，以便更快地查找和存储对象。</p>
</li>
<li class="lvl-4">
<p>finalize：当java对象被回收时，由GC自动调用被回收对象的finalize方法，通常在该方法中完成销毁前的准备。</p>
</li>
<li class="lvl-4">
<p>clone：对象的拷贝。（浅拷贝，深拷贝）</p>
<ul class="lvl-4">
<li class="lvl-6">protected修饰的只能在同一个包下或者子类中访问。</li>
<li class="lvl-6">只有实现了Cloneable接口的对象才能被克隆。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Object类中的toString()方法</strong></p>
<ol>
<li class="lvl-3">
<p>Object类设计toString()方法的目的是什么？</p>
<ul class="lvl-2">
<li class="lvl-6">这个方法的作用是：将java对象转换成字符串的表示形式。</li>
</ul>
</li>
<li class="lvl-3">
<p>Object类中toString()方法的默认实现是怎样的？</p>
<ul class="lvl-2">
<li class="lvl-6">
<p>默认实现是：完整类名 + @ + 十六进制的数字</p>
</li>
<li class="lvl-6">
<p>这个输出结果可以等同看做一个java对象的内存地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><strong>Object类中的equals方法：</strong></p>
<ol>
<li class="lvl-3">
<p>Object类设计equals方法的作用是什么？目的是什么？</p>
<ul class="lvl-2">
<li class="lvl-6">
<p>equals方法的作用是：判断两个对象是否相等。</p>
</li>
<li class="lvl-6">
<p>equals方法的返回值是true/false</p>
<ul class="lvl-4">
<li class="lvl-8">true代表两个对象相等。</li>
<li class="lvl-8">false代表两个对象不相等。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>Object类中对equals方法的默认实现是怎样的？</p>
<ul class="lvl-2">
<li class="lvl-6">
<p>a.equals(b) 表面是a和b的比较。实际上方法体当中是：this和obj的比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li class="lvl-3">
<p>关于 == 运算符的运算规则：</p>
<ul class="lvl-2">
<li class="lvl-6"><code>== 永远只有一个运算规则，永远比较的是变量中保存的值之间的比较。</code>​</li>
<li class="lvl-6">只不过有的时候这个值是基本数据类型。有的时候这个值是对象的内存地址。</li>
</ul>
</li>
<li class="lvl-3">
<p>equals方法为什么要重写？</p>
<ul class="lvl-2">
<li class="lvl-6">因为Object类中的equals方法在进行比较的时候，比较的是两个java对象的内存地址。</li>
<li class="lvl-6">我们希望比较的是对象的内容。只要对象的内容相等，则认为是相同的。</li>
</ul>
</li>
<li class="lvl-3">
<p>字符串的比较不能使用 <code>==</code>​, 必须使用equals方法进行比较</p>
</li>
<li class="lvl-3">
<p>字符串String类型已经重写了equals方法</p>
</li>
</ol>
<p><strong>关于Object类的hashCode()方法：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>hashCode：返回一个对象的哈希值，通常作为在哈希表中查找该对象的键值。</p>
</li>
<li class="lvl-2">
<p>Object类的默认实现是根据对象的内存地址生成一个哈希码（即将对象的内存地址转换为整数作为哈希值）。</p>
</li>
<li class="lvl-2">
<p>hashCode()方法是为了HashMap、Hashtable、HashSet等集合类进行优化而设置的，以便更快地查找和存储对象</p>
</li>
<li class="lvl-2">
<p>hashCode()方法在Object类中的默认实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-4">
<p>这是一个本地方法，底层调用了C++写的动态链接库程序：xxx.dll</p>
</li>
</ul>
</li>
</ul>
<p><strong>关于Object类中的clone()方法：</strong></p>
<ol>
<li class="lvl-3">
<p>clone方法作用：对象拷贝。通常在开发中需要保护原对象数据结构。通常复制一份，生成一个新对象，对新对象进行操作。</p>
</li>
<li class="lvl-3">
<p>Object类中的默认实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br><span class="line"> *      受保护的方法，专门给子类使用的。</span><br><span class="line"> *      本地方法。</span><br><span class="line"> *      底层调用C++程序已经可以完成对象的创建了。</span><br><span class="line"> *      我们现在要解决的问题是：怎么调用这个方法。</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>怎么解决clone()方法的调用问题？</p>
<ul class="lvl-2">
<li class="lvl-6">在子类中重写该clone()方法。</li>
<li class="lvl-6">为了保证clone()方法在任何位置都可以调用，建议将其修饰符修改为：public</li>
</ul>
</li>
<li class="lvl-3">
<p>凡事参加克隆的对象，必须实现一个标志接口：java.lang.Cloneable</p>
<ol>
<li class="lvl-7">
<p>java中接口包括两大类：</p>
<ol>
<li class="lvl-11">一类是：起到标志的作用，标志型接口。</li>
<li class="lvl-11">另一类是：普通接口。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>内部类</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>什么是内部类？</p>
<ul class="lvl-2">
<li class="lvl-4">定义在一个类中的类。</li>
</ul>
</li>
<li class="lvl-2">
<p>什么时候使用内部类？</p>
<ul class="lvl-2">
<li class="lvl-4">一个类用到了另外一个类，而这两个类的联系比较密切，但是如果把这两个类定义为独立的类，不但增加了类的数量，也不利于代码的阅读和维护。</li>
<li class="lvl-4">内部类可以访问外部类的私有成员，这样可以将相关的类和接口隐藏在外部类的内部，从而提高封装性。</li>
<li class="lvl-4">匿名内部类是指没有名字的内部类，通常用于定义一个只使用一次的类，比如在事件处理中。</li>
</ul>
</li>
<li class="lvl-2">
<p>内部类包括哪几种？</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>静态内部类：和静态变量一个级别</p>
<ul class="lvl-4">
<li class="lvl-6">静态内部类如何实例化：OuterClass.StaticInnerClass staticInnerClass = new OuterClass.StaticInnerClass();</li>
<li class="lvl-6">无法直接访问外部类中实例变量和实例方法。</li>
</ul>
</li>
<li class="lvl-4">
<p>实例内部类：和实例变量一个级别</p>
<ul class="lvl-4">
<li class="lvl-6">实例内部类如何实例化：OuterClass.InnerClass innerClass = new OuterClass().new InnerClass();</li>
<li class="lvl-6">可以直接访问外部类中所有的实例变量，实例方法，静态变量，静态方法。</li>
</ul>
</li>
<li class="lvl-4">
<p>局部内部类：和局部变量一个级别</p>
<ul class="lvl-4">
<li class="lvl-6">局部内部类方外类外部的局部变量时，局部变量需要被final修饰。</li>
<li class="lvl-6">从JDK8开始，不需要手动添加final了，但JVM会自动添加。</li>
</ul>
</li>
<li class="lvl-4">
<p>匿名内部类：特殊的局部内部类，没有名字，只能用一次。</p>
<ul class="lvl-4">
<li class="lvl-6">匿名内部类：特殊的局部内部类，没有名字，只能用一次。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>‍</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>第五章：面向对象编程</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://northpoet.github.io/posts/aa351366.html">https://northpoet.github.io/posts/aa351366.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>捞月亮の小北</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-07-18</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-07-27</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/wallhaven-7poj6e-20240202213535-pv6wlwq.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/b492def1.html" title="第六章：异常"><img class="cover" src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/1.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第六章：异常</div></div></a></div><div class="next-post pull-right"><a href="/posts/a9867134.html" title="第四章：数组"><img class="cover" src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/wallhaven-jxl31y-20240119141212-y4vupt3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第四章：数组</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/f7c947df.html" title="第一章：Java语言概述"><img class="cover" src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/wallhaven-p9vjq9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-17</div><div class="title">第一章：Java语言概述</div></div></a></div><div><a href="/posts/1fcb7e57.html" title="第三章：流程控制语句"><img class="cover" src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/wallhaven-l8vp7y.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-18</div><div class="title">第三章：流程控制语句</div></div></a></div><div><a href="/posts/28b3fa6.html" title="第二章：变量与运算符"><img class="cover" src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/wallhaven-vqvzzp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-17</div><div class="title">第二章：变量与运算符</div></div></a></div><div><a href="/posts/b492def1.html" title="第六章：异常"><img class="cover" src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-18</div><div class="title">第六章：异常</div></div></a></div><div><a href="/posts/a9867134.html" title="第四章：数组"><img class="cover" src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/wallhaven-jxl31y-20240119141212-y4vupt3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-18</div><div class="title">第四章：数组</div></div></a></div><div><a href="/posts/cca6755e.html" title="2.变量与运算符"><img class="cover" src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/wallhaven-qzmlo7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-27</div><div class="title">2.变量与运算符</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="card-info-avatar"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://lskypro.acozycotage.net/LightPicture/2022/12/fe1dc0402e623096.jpg">🐟</g-emoji><span>认真摸鱼中</span></div></div><div class="author-info__name">捞月亮の小北</div><div class="author-info__description">言念君子 ，温其如玉</div></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/NorthPoet"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">吾心安处即吾乡,吾乡何处不可眠</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 面向对象概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-text">2. 类与对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-text">3. 对象的内存分析(对象与引用)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B0%81%E8%A3%85"><span class="toc-text">4. 封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95Constructor%EF%BC%88%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%89"><span class="toc-text">5. 构造方法Constructor（构造器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-this-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">6. this 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">7. static 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">8. JVM体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">9. 单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E7%BB%A7%E6%89%BF"><span class="toc-text">10. 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96"><span class="toc-text">11. 方法覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%A4%9A%E6%80%81"><span class="toc-text">12. 多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">13. super关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">14. final关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">15. 抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%8E%A5%E5%8F%A3"><span class="toc-text">16. 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-UML"><span class="toc-text">17. UML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90"><span class="toc-text">18. 访问控制权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-Object-%E7%B1%BB"><span class="toc-text">19. Object 类</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/442fdc66.html" title="自定义Callout样式"><img src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/north-01.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自定义Callout样式"/></a><div class="content"><a class="title" href="/posts/442fdc66.html" title="自定义Callout样式">自定义Callout样式</a><time datetime="2024-07-29T06:32:31.000Z" title="发表于 2024-07-29 14:32:31">2024-07-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a0708e01.html" title="Butterfly 主题美化之旅：从绚烂回归质朴"><img src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/wallhaven-2yw1xx.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Butterfly 主题美化之旅：从绚烂回归质朴"/></a><div class="content"><a class="title" href="/posts/a0708e01.html" title="Butterfly 主题美化之旅：从绚烂回归质朴">Butterfly 主题美化之旅：从绚烂回归质朴</a><time datetime="2024-07-28T07:27:21.000Z" title="发表于 2024-07-28 15:27:21">2024-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8fd19ba2.html" title="秒杀优化-基于阻塞队列实现秒杀优化"><img src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/wallhaven-expxmw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="秒杀优化-基于阻塞队列实现秒杀优化"/></a><div class="content"><a class="title" href="/posts/8fd19ba2.html" title="秒杀优化-基于阻塞队列实现秒杀优化">秒杀优化-基于阻塞队列实现秒杀优化</a><time datetime="2024-07-27T03:00:16.000Z" title="发表于 2024-07-27 11:00:16">2024-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5c81b531.html" title="大事件"><img src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/wallhaven-gpxxq7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大事件"/></a><div class="content"><a class="title" href="/posts/5c81b531.html" title="大事件">大事件</a><time datetime="2024-07-23T08:11:57.000Z" title="发表于 2024-07-23 16:11:57">2024-07-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/facab7a2.html" title="我在人间凑数的日子"><img src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/x-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我在人间凑数的日子"/></a><div class="content"><a class="title" href="/posts/facab7a2.html" title="我在人间凑数的日子">我在人间凑数的日子</a><time datetime="2024-07-19T23:56:57.000Z" title="发表于 2024-07-20 07:56:57">2024-07-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 捞月亮の小北</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23liH3xSwqydS0B0nh',
      clientSecret: '6dbf9f55347c719995768d8f980061ff721ea71a',
      repo: 'NorthPoet.github.io.gitalk',
      owner: 'NorthPoet',
      admin: ['NorthPoet'],
      id: '7294f987c9f32daba016456e37a82893',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script src="/js/sun_moon.js" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/8ebfad52.html" alt=""><img width="48" height="48" src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/wallhaven-6d6jk6.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-17</span><a class="blog-slider__title" href="posts/8ebfad52.html" alt="">闲言碎语</a><div class="blog-slider__text">我大抵是真的眼花了，竟把一个人的落日，看成了两个人的黄昏</div><a class="blog-slider__button" href="posts/8ebfad52.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/facab7a2.html" alt=""><img width="48" height="48" src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/x-12.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-20</span><a class="blog-slider__title" href="posts/facab7a2.html" alt="">我在人间凑数的日子</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="posts/facab7a2.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/5413be0e.html" alt=""><img width="48" height="48" src="https://cdn.jsdelivr.net/gh/NorthPoet/images/images/a-13.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" href="posts/5413be0e.html" alt="">健身日记</a><div class="blog-slider__text">在平淡腐朽的日子里，我一定会熠熠生辉</div><a class="blog-slider__button" href="posts/5413be0e.html" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>